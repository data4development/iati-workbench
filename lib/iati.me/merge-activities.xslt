<?xml version="1.0" encoding="UTF-8"?>
<!--  IATI workbench: produce and use IATI data
  Copyright (C) 2016-2022, drostan.org and data4development.org

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published
  by the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<!--
  This styleheet merges IATI activity elements into a predictable sequence:
  it follows the IATI Standard, and sorts activities and elements within activities.
  This should make standard file versioning more useful when inspecting the results.
  See the detailed remarks for more information.

  It also does some deduplication of elements based on "best effort":
  * Repeated elements will not be included.
  * Attributes with empty values will not be included.

-->
<xsl:stylesheet version='3.0'
  xmlns:xsl='http://www.w3.org/1999/XSL/Transform'
  xmlns:merge="http://aida.tools/merge"
  xmlns:functx="http://www.functx.com"
  expand-text="yes"
  exclude-result-prefixes="#all">

  <xsl:output indent="yes"/>

  <xsl:template name="merge-activities">
    <xsl:param name="input-activities"/>
    <xsl:comment>This file has been generated by the AIDA converter service. See https://aida.tools for more information</xsl:comment>
    <iati-activities version="2.03" generated-datetime="{current-dateTime()}"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="http://iatistandard.org/203/schema/downloads/iati-activities-schema.xsd">
      <!-- Gather all elements per activity, and sort them by identifier -->
      <xsl:for-each-group select="$input-activities" group-by="functx:trim(@merge:id)">
        <xsl:sort select="current-grouping-key()"/>

        <!-- select the first default language attribute -->
        <xsl:variable name="default-lang" select="(current-group()/@xml:lang, 'en')[1]"/>

        <!-- if the activity is not excluded -->
        <xsl:if test="not(@merge:exclude='true')">
          <iati-activity>
            <xsl:copy-of select="current-group()/@*[.!='' and not(name(.)=('merge:id', 'merge:exclude', 'xml:lang'))]" />
            <xsl:attribute name="xml:lang" select="$default-lang"/>
            <iati-identifier><xsl:copy-of select="current-grouping-key()"/></iati-identifier>
            <xsl:apply-templates select="(current-group()/reporting-org)[1]">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>

            <xsl:where-populated>
              <title>
                <xsl:call-template name="narratives">
                  <xsl:with-param name="narratives" select="current-group()/title/narrative[.!='']"/>
                  <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                </xsl:call-template>
              </title>
            </xsl:where-populated>

            <xsl:for-each-group select="current-group()/description" group-by="@type">
              <xsl:where-populated>
                <description>
                  <xsl:on-non-empty>
                    <!-- include attributes if there are narratives -->
                    <xsl:copy-of select="current-group()/@*" />
                  </xsl:on-non-empty>

                  <xsl:call-template name="narratives">
                    <xsl:with-param name="narratives" select="current-group()/narrative[.!='']"/>
                    <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                  </xsl:call-template>
                </description>
              </xsl:where-populated>
            </xsl:for-each-group>

            <xsl:for-each-group select="current-group()/participating-org" group-by="@role">
              <!-- all orgs with refs -->
              <xsl:for-each-group select="current-group()[@ref!='']" group-by="@ref">
                <xsl:apply-templates select="current-group()[1]">
                  <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                </xsl:apply-templates>
              </xsl:for-each-group>
              <!-- all orgs without refs -->
              <xsl:for-each-group select="current-group()[not(@ref) or @ref='']" group-by="narrative[1]">
                <xsl:apply-templates select="current-group()[1]">
                  <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                </xsl:apply-templates>
              </xsl:for-each-group>
            </xsl:for-each-group>

            <xsl:apply-templates select="current-group()/other-identifier"/>
            <xsl:for-each-group select="current-group()/activity-status[@code!='']" group-by="@code">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>

            <xsl:for-each-group select="current-group()/activity-date[@iso-date!='']" group-by="@type">
              <xsl:sort select="@iso-date"/>
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>

            <xsl:for-each-group select="current-group()/contact-info" group-by="@type">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>
            <xsl:for-each-group select="current-group()/activity-scope[@code!='']" group-by="@code">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>

            <xsl:for-each-group select="current-group()/recipient-country" group-by="@code">
              <xsl:for-each-group select="current-group()" group-by="@percentage">
                <xsl:apply-templates select="current-group()[1]">
                  <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                </xsl:apply-templates>
              </xsl:for-each-group>
            </xsl:for-each-group>

            <xsl:apply-templates select="current-group()/recipient-region[@code!='']">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/location">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>

            <xsl:for-each-group select="current-group()/sector" group-by="@vocabulary">
              <xsl:for-each-group select="current-group()" group-by="@code">
                <xsl:for-each-group select="current-group()" group-by="@percentage">
                  <xsl:apply-templates select="current-group()[1]">
                    <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                  </xsl:apply-templates>
                </xsl:for-each-group>
              </xsl:for-each-group>
            </xsl:for-each-group>

            <xsl:apply-templates select="current-group()/tag">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/country-budget-items">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/humanitarian-scope">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/policy-marker">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>

            <xsl:for-each-group select="current-group()/collaboration-type[@code!='']" group-by="@code">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>
            <xsl:for-each-group select="current-group()/default-flow-type[@code!='']" group-by="@code">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>
            <xsl:for-each-group select="current-group()/default-finance-type[@code!='']" group-by="@code">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>
            <xsl:for-each-group select="current-group()/default-aid-type[@code!='']" group-by="@code">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>
            <xsl:for-each-group select="current-group()/default-tied-status[@code!='']" group-by="@code">
              <xsl:apply-templates select="current-group()[1]">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>

            <xsl:for-each-group select="current-group()/budget" group-by="@type">
              <!-- TODO split by @status as well -->
              <xsl:apply-templates select="current-group()">
                <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
              </xsl:apply-templates>
            </xsl:for-each-group>

            <xsl:apply-templates select="current-group()/planned-disbursement">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/capital-spend">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/transaction[transaction-type/@code!='' and value!='']">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/document-link[@url!='']">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>

            <xsl:for-each-group select="current-group()/related-activity" group-by="@ref">
              <xsl:for-each-group select="current-group()" group-by="@type">
                <xsl:apply-templates select="current-group()[1]">
                  <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                </xsl:apply-templates>
              </xsl:for-each-group>
            </xsl:for-each-group>

            <xsl:if test="current-group()/conditions/condition/narrative">
              <conditions attached="1">
                <xsl:for-each-group select="current-group()/conditions/condition" group-by="@type">
                  <xsl:variable name="ctype" select="current-grouping-key()"/>
                  <xsl:for-each-group select="current-group()" group-by="narrative">
                      <condition type="{$ctype}">
                        <!-- TODO add language -->
                        <narrative>{current-grouping-key()}</narrative>
                      </condition>
                  </xsl:for-each-group>
                </xsl:for-each-group>
              </conditions>
            </xsl:if>

            <xsl:for-each-group select="current-group()/result" group-by="@merge:id">
              <xsl:if test="current-group()/indicator/title/narrative/text() and current-group()/@type">
                <result>
                  <xsl:copy-of select="current-group()/@*[.!='' and name(.)!='merge:id']" />
                  <!-- TODO find the proper way to avoid duplicates... this may eliminate multiple language versions -->
                  <xsl:apply-templates select="(current-group()/title)[1]">
                    <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                  </xsl:apply-templates>
                  <xsl:apply-templates select="(current-group()/description)[1]">
                    <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                  </xsl:apply-templates>
                  <xsl:apply-templates select="current-group()/*[not(name()=('title', 'description', 'indicator'))]">
                    <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                  </xsl:apply-templates>
                  <xsl:for-each-group select="current-group()/indicator" group-by="@merge:id">
                    <indicator>
                      <xsl:copy-of select="current-group()/@*[.!='' and name(.)!='merge:id']"/>
                      <!-- TODO find the proper way to avoid duplicates... this may eliminate multiple language versions, and multiple baselines versions -->
                      <xsl:apply-templates select="(current-group()/title)[1]">
                        <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                      </xsl:apply-templates>
                      <xsl:apply-templates select="(current-group()/description)[1]">
                        <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                      </xsl:apply-templates>
                      <xsl:for-each-group select="current-group()/reference" group-by="@vocabulary">
                        <xsl:for-each-group select="." group-by="@code">
                          <xsl:copy-of select="." copy-namespaces="no"/>
                        </xsl:for-each-group>
                      </xsl:for-each-group>
                      <!-- TODO: commented out code: What does it do, why is it commented out, will we need it in the future? If not, feel free to remove. -->
                      <!-- <xsl:apply-templates select="current-group()/reference"/> -->
                      <xsl:for-each-group select="current-group()/baseline" group-by="@merge:id">
                        <baseline>
                          <xsl:copy-of select="current-group()/@*[.!='' and name(.)!='merge:id']" />
                          <xsl:apply-templates select="current-group()[1]/dimension">
                            <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                          </xsl:apply-templates>
                          <xsl:apply-templates select="current-group()[1]/comment">
                            <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                          </xsl:apply-templates>
                        </baseline>
                      </xsl:for-each-group>
                      <xsl:apply-templates select="current-group()/*[not(name()=('title', 'description', 'baseline', 'reference'))]">
                        <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                      </xsl:apply-templates>
                      <!-- TODO: commented out code: What does it do, why is it commented out, will we need it in the future? If not, feel free to remove. -->
                      <!-- <xsl:copy-of select="current-group()/*[not(name()=('title', 'description', 'baseline'))]" copy-namespaces="no"/> -->
<!--                      <xsl:apply-templates select="current-group()/*">
                        <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
                      </xsl:apply-templates> -->
                    </indicator>
                  </xsl:for-each-group>
                </result>
              </xsl:if>
            </xsl:for-each-group>

            <xsl:apply-templates select="current-group()/resultcrs-add">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
            <xsl:apply-templates select="current-group()/fss">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>

            <xsl:apply-templates select="current-group()/*[namespace-uri()]">
              <xsl:with-param name="default-lang" select="$default-lang" tunnel="yes"/>
            </xsl:apply-templates>
          </iati-activity>
        </xsl:if>
      </xsl:for-each-group>
    </iati-activities>
  </xsl:template>

  <!-- ignore these elements: -->

  <!-- text elements without any narrative element with actual content -->
  <xsl:template match="title                [not(narrative[.!=''])]"/>
  <xsl:template match="description          [not(narrative[.!=''])]"/>
  <xsl:template match="comment              [not(narrative[.!=''])]"/>
  <xsl:template match="condition            [not(narrative[.!=''])]"/>
  <xsl:template match="organisation         [not(narrative[.!=''])]"/>
  <xsl:template match="department           [not(narrative[.!=''])]"/>
  <xsl:template match="person-name          [not(narrative[.!=''])]"/>
  <xsl:template match="job-title            [not(narrative[.!=''])]"/>
  <xsl:template match="mailing-address      [not(narrative[.!=''])]"/>
  <xsl:template match="name                 [not(narrative[.!=''])]"/>
  <xsl:template match="activity-description [not(narrative[.!=''])]"/>

  <xsl:template match="telephone[.='']"/>

  <xsl:template match="provider-org[not(@*[.!='']) and not(narrative[.!=''])]"/>
  <xsl:template match="receiver-org[not(@*[.!='']) and not(narrative[.!=''])]"/>

  <xsl:template match="period[not(target) and not(actual)]"/>

  <!-- targets or actuals without values -->
  <xsl:template match="target[not(@value) or @value='']"/>
  <xsl:template match="actual[not(@value) or @value='']"/>

  <!-- other empty elements -->
  <xsl:template match="policy-marker[@code='']"/>
  <xsl:template match="point[normalize-space(pos)='']"/>
  <xsl:template match="location-reach[@code='']"/>
  <xsl:template match="location-id[@code='']"/>
  <xsl:template match="administrative[@code='']"/>
  <xsl:template match="exactness[@code='']"/>
  <xsl:template match="feature-designation[@code='']"/>

  <xsl:template match="related-activity[@ref='']"/>

  <!-- TODO: commented out code: What does it do, why is it commented out, will we need it in the future? If not, feel free to remove. -->
  <!-- <xsl:template match="collaboration-type   [@code=(parent::collaboration-type/@code)]"/> -->
  <!-- <xsl:template match="collaboration-type">
    <collaboration-type code="{@code}">
      <xsl:copy-of select="parent::*[name()='collaboration-type']"/>
    </collaboration-type>
  </xsl:template> -->

</xsl:stylesheet>
